#lang sicp

;(define (p) (p))
;
;(define (test x y)
;    (if (= x 0)
;        0
;        y))
;
;(test 0 (p))
;
;Для начала отметим, что процедура (р) представляет из себя бесконечный цикл.
;
;1. Аппликативный порядок вычислений
;При аппликативном порядке вычислений, интерпретатор сначала пытается вычислить значение оператора и операндов, а затем применяет получившуюся процедуру к получившимся аргументам.
;При попытке вычислить значение операнда (р) интерпретатор попадает в бесконечный цикл и программа "зависает".
;(test 0 (p))
;Шаг 1 - Вычисляем test, 0 и (р)
;0 -> 0
;(p) -> (p) -> (p) -> (p) и т.д.
;test -> (if (= x 0) 0 y)
;
;2. Нормальный порядок вычислений
;При нормальном порядке вычислений, интерпретатор сначала подставляет на места параметров выражения-операнды, не вычисляя их. Этот процесс продолжается до тех пор, пока в выражении не останутся только элементарные операторы.
;(test 0 (p))
;((if (= x 0) 0 y) 0 (p)) ; теперь просто подставляем операнды
;(if (= 0 0) 0 (p)) ; вычисляем особую форму if. В ней первм делом вычисляется предикат.
;(= 0 0)-> #t ; Предикат истенет, вычисляем первый параметр
;0 -> 0

